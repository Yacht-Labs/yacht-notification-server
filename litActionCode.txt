
    const go = async () => {
        const originTime = undefined ? undefined : Date.now();
        const chainACondition = {"conditionType":"evmBasic","contractAddress":"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174","standardContractType":"ERC20","chain":"mumbai","method":"balanceOf","parameters":["address"],"returnValueTest":{"comparator":">=","value":"10000000000000000000"}}
        const chainBCondition = {"conditionType":"evmBasic","contractAddress":"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174","standardContractType":"ERC20","chain":"kovan","method":"balanceOf","parameters":["address"],"returnValueTest":{"comparator":">=","value":"10000000000000000000"}}
        const chainATransaction = {"to":"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174","nonce":0,"chainId":80001,"maxFeePerGas":"102000000000","maxPriorityFeePerGas":"100000000000","gasLimit":"1000000","from":"{{pkpPublicKey}}","data":"0xa9059cbb000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000008ac7230489e80000","type":2}
        const chainBTransaction = {"to":"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174","nonce":0,"chainId":42,"maxFeePerGas":"102000000000","maxPriorityFeePerGas":"100000000000","gasLimit":"1000000","from":"{{pkpPublicKey}}","data":"0xa9059cbb000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000008ac7230489e80000","type":2}
        const chainAClawbackTransaction = {"to":"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174","nonce":0,"chainId":80001,"maxFeePerGas":"102000000000","maxPriorityFeePerGas":"100000000000","gasLimit":"1000000","from":"{{pkpPublicKey}}","data":"0xa9059cbb000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000008ac7230489e80000","type":2}
        const chainBClawbackTransaction = {"to":"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174","nonce":0,"chainId":42,"maxFeePerGas":"102000000000","maxPriorityFeePerGas":"100000000000","gasLimit":"1000000","from":"{{pkpPublicKey}}","data":"0xa9059cbb000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000008ac7230489e80000","type":2}
        const hashTransaction = (tx) => {
          return ethers.utils.arrayify(
            ethers.utils.keccak256(
              ethers.utils.arrayify(ethers.utils.serializeTransaction(tx)),
            ),
          );
        }
      
        function checkHasThreeDaysPassed(previousTime) {
            const currentTime = Date.now();
            const difference = currentTime - previousTime;
            return difference / (1000 * 3600 * 24) >= 3 ? true : false;
        }
        
        const generateSwapTransactions = async () => {
          await LitActions.signEcdsa({
            toSign: hashTransaction(chainATransaction),
            publicKey: pkpPublicKey,
            sigName: "chainASignature",
          });
          await LitActions.signEcdsa({
            toSign: hashTransaction(chainBTransaction),
            publicKey: pkpPublicKey,
            sigName: "chainBSignature",
          });
          Lit.Actions.setResponse({
            response: JSON.stringify({ chainATransaction, chainBTransaction }),
          });
        };
      
        chainACondition.parameters = chainBCondition.parameters = [
          pkpAddress,
        ];
        chainATransaction.from = chainBTransaction.from = pkpAddress;
      
        const chainAConditionsPass = await Lit.Actions.checkConditions({
          conditions: [chainACondition],
          authSig,
          chain: chainACondition.chain,
        });
      
        const chainBConditionsPass = await Lit.Actions.checkConditions({
          conditions: [chainBCondition],
          authSig,
          chain: chainBCondition.chain,
        });
      
        if (chainAConditionsPass && chainBConditionsPass) {
          await generateSwapTransactions();
          return;
        }
      
        const threeDaysHasPassed = checkHasThreeDaysPassed(originTime);
        const chainANonce = await Lit.Actions.getLatestNonce({address: pkpAddress, chain: chainACondition.chain});
        const chainBNonce = await Lit.Actions.getLatestNonce({address: pkpAddress, chain: chainBCondition.chain});

        if (chainAConditionsPass) {
          if (chainBNonce === 1) {
            await generateSwapTransactions();
            return;
          }
          if (!threeDaysHasPassed) {
            Lit.Actions.setResponse({ response: "Conditions for swap not met!" });
            return;
          }
          await Lit.Actions.signEcdsa({
            toSign: hashTransaction(chainAClawbackTransaction),
            publicKey: pkpPublicKey,
            sigName: "chainASignature",
          });
          Lit.Actions.setResponse({
            response: JSON.stringify({
              chainATransaction: chainAClawbackTransaction,
            }),
          });
          return;
        }
      
        if (chainBConditionsPass) {
          if (chainANonce === 1) {
            await generateSwapTransactions();
            return;
          }
          if (!threeDaysHasPassed) {
            Lit.Actions.setResponse({ response: "Conditions for swap not met!" });
            return;
          }
          await Lit.Actions.signEcdsa({
            toSign: hashTransaction(chainBClawbackTransaction),
            publicKey: pkpPublicKey,
            sigName: "chainBSignature",
          });
          Lit.Actions.setResponse({
            response: JSON.stringify({
              chainBTransaction: chainBClawbackTransaction,
            }),
          });
          return;
        }
        Lit.Actions.setResponse({ response: "Conditions for swap not met!" });
      }
    go();
    